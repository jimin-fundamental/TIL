# 20250204: 다양한 객체 생성과 수정, 성능 최적화 고민, 대규모 시스템 아키텍처 설계, 그리고 데이터베이스와 GC의 핵심 개념 정리

## 💡 Key Context
> 오늘은 객체지향 설계의 핵심인 빌더와 ToBuilder 개념, 성능과 관련된 인덱스와 Lock, MVCC 이해, 그리고 대규모 시스템을 위한 아키텍처 전략들에 대해 탐구함.
>-db 관련해서는 정규화와 ACID + Isolation, 그리고 GC 개념을 다시 정리하며 메모리와 성능에 대한 고민도 병행했음.

## 🔍 Deep Dive & Reasoning
- 빌더와 ToBuilder는 불변 객체를 다루는 데 필수적이며, 객체 수정과 최적화에 핵심임. 완전하지 않아도 왜 이렇게 동작하는지 기반 원리를 이해하는 게 중요할 것 같음.
- 인덱스는 읽기 성능 향상에 유리하지만, 쓰기 시 인덱스 업데이트 비용 문제도 고려해야 함. 이 교환관계를 왜 고려해야 하는지 개인적 가설도 세워봄.
- 샤딩과 Master-Slave 구조는 읽기성능 향상과 확장성을 위해 필요하다는 건 알겠지만, 연관된 트랜잭션과 조인 문제, 그리고 트랜잭션 관리의 어려움이 실무에 끼치는 영향을 생각하며 설계 후 결정하는 게 맞는 것 같음.
- Saga 패턴은 분산 트랜잭션 이슈의 해결책. 코레오그래피와 오케스트레이션의 차이, 메시지 브로커 활용의 배경이 궁금해지고 어떻게 구현할지에 대한 구상도 병행.
- 데이터 정규화와 ACID는 이론적 기반이지만, 실무에서는 성능과 비용을 감안해서 적절한 수준을 선택하는 것인지 근본적 이유를 다시 고민해봄.
- Isolation과 부작용 개념은 특히 병행성 문제가 심각한 곳에서 꼭 기억해야 할 핵심이다. 이 세 가지 부작용이 왜 위험한지, 각각의 사례를 떠올리며 내공을 쌓을 것.
- Lock과 MVCC 다큐먼트는 성능과 병행성 조절의 핵심. 더 나아가 GC 개념과 세대별 가설이 메모리 관리의 이해도를 높여줌. 특히 System.gc() 사용을 자제하는 이유는 성능 유지에 매우 중요한 포인트.

## 🛠️ Troubleshooting & Insight
- GC 와 STW는 예상보다 더 많은 고민이 필요하다고 느꼈음. 실무에서는 GC 튜닝이나 조기 호출 방지 정책이 얼마나 중요한지 점검 필요.
- 인덱스와 Lock 전략은 깊은 고려가 필요한 부분임을 깨달았고, 특히 MVCC의 Undo Log가 이 방식을 가능하게 해준다는 점에서 더 이해가 깊어짐.
- 트랜잭션 격리수준과 부작용 설명은, 동시성 제어 문제를 해결하는 실전 방책과 연계해서 재검토했음.

## 🎯 Next Step
- 지금 배운 이론을 실제 구현 사례에 어떻게 적용할 수 있을지, 각 아키텍처 설계별 트레이드오프 사례를 수집하고 정리할 필요가 있음.