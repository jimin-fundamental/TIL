# 20240427: 빌더와 인덱스, 분산 아키텍처에 대한 고민과 학습

## 💡 Key Context
> 오늘은 객체 생성 방식인 Builder와 ToBuilder의 의미, 인덱스의 성능 트레이드오프, 그리고 서버 확장 및 분산 트랜잭션 처리를 위한 아키텍처 등에 대해 정리하며 나의 이해를 다시 확인하는 시간이었음. 이것들이 실무에서 왜 중요한지, 어떤 문제와 직면했고 어떻게 대응할지 고민하는 계기임.

## 🔍 Deep Dive & Reasoning
- Builder는 주로 새 객체를 만들어 낼 때 사용되고, ToBuilder는 기존 객체를 기반으로 일부만 수정된 새 객체를 만들어내는 용도인 것 같음. 특히, 불변 객체를 다룰 때 필수적이라는 점이 핵심임. 왜냐하면, 불변성을 유지하기 위해 기존 객체를 수정하는 대신 새로 생성하는 방식이니까.
- 인덱스는 읽기 속도는 향상시키지만, 쓰기 성능에는 부담이 된다는 건 일반적인 생각이지만, 정확한 시점들이 계속 고민됨. 인덱스 추가는 쓰기 비용을 증가시키는 대신, 읽기 효율을 크게 높임. 트레이드오프의 핵심은 용량과 성능 사이의 균형.
- 분산 아키텍처에서는 Master-Slave와 Sharding이 자주 언급되었는데, 읽기 부하 분산과 데이터 쪼개기의 개념이 이해는 되지만, 이로 인해 생기는 Join 등 데이터 연관성 문제, 트랜잭션 복잡도가 엄청 늘어난다는 실무적 한계가 와닿음.
- Saga 패턴은 결국 여러 서버에 분산된 데이터 일관성을 해결하는 방법임. Choreography와 Orchestration의 차이는 자율성 대비 중앙 제어 여부로 보이며, 메시지 브로커 각각의 장단점이 각기 다르게 작용하는 것을 알게 됨.
- 데이터 정규화는 1NF에서 6NF까지의 흐름, 그리고 표준은 3NF/BCNF라는 점. ACID 원칙은 확실히 기억해야겠다고 느낌. 특히, 트랜잭션이 '더 이상 쪼갤 수 없는 논리적 단위'라는 정의는 명확히 복습 필요.
- Isolation과 부작용(Dirty, Non-Repeatable, Phantom Read) 는 격리 수준이 완벽하지 않음을 보여주며, 성능과 일관성 사이에서 균형 잡기가 관건이라는 결론.
- Lock과 MVCC는 성능 최적화 핵심으로, 읽기와 쓰기 각각의 유리한 방식을 취하는 기술적 배경을 이해하며, Undo Log를 통해 Lock에 따른 대기 문제를 완화하는 점이 흥미로움.
- 마지막으로, GC의 역할과 문제점, 특히 STW와 System.gc() 호출이 초래하는 성능 저하, 그리고 세대별 가설이 이러한 메모리 관리를 효율적으로 유지하는 핵심임을 다시 정리.

## 🛠️ Troubleshooting & Insight
> 각 토픽별로 나의 의문은 확실히 정리됨. 불변 객체와 ToBuilder의 차이, 인덱스의 Update 비용, Sharding으로 인한 트랜잭션 어려움, 그리고 GC의 세대별 가설 등 실무에서 부딪칠 문제와 그 대응책을 논리적으로 정리하는 게 핵심임. 작은 실수라도 놓치지 않기 위해, 앞으로 각 주제별로 간단한 정리와 실습으로 체득하는 과정이 필요하다고 느낌.

## 🎯 Next Step
- 각 개념별로 간단한 예제 코드를 만들어보며, 왜 그렇게 동작하는지 논리적으로 설명할 수 있을 정도로 이해를 정리할 것.