# 20260204: 객체 설계와 DB 최적화의 핵심 개념들을 이해하려고 노력함

## 💡 Key Context
> 오늘은 객체 생성 방식, 성능 최적화, 대규모 시스템 아키텍처, 분산 트랜잭션, 그리고 데이터베이스 정규화와 ACID 원칙 등 여러 핵심 개념을 정리하는 시간을 가졌음. 특히, 실무에서 겪은 고민들과 그에 대한 해결책들에 대해 깊게 생각해보았음.

## 🔍 Deep Dive & Reasoning
- 빌더 패턴과 ToBuilder의 차이점을 통해 불변 객체를 효과적으로 다루는 방법에 대해 다시 한 번 정리했음. 이게 왜 중요한지에 대한 이해가 깊어지는 계기였고, 기존 객체를 기반으로 부분 수정하는 과정이 Immutable Object 관리에 필수임을 깨달았음.
- 인덱스의 장단점을 다시 살펴보면서, 읽기 성능 향상을 위해 인덱스를 무조건 추가하는 게 항상 좋은 선택은 아니란 점에 공감. 쓰기 성능과 조회 속도 사이의 트레이드오프를 신중히 고려해야 함.
- 서버 확장과 관련된 아키텍처는 실무에 바로 적용 가능한 개념들이었음. 샤딩과 Master-Slave의 장단점, 그리고 트랜잭션을 포기하지 않으면서도 확장하는 방법에 대해 다시 생각했음. 특히, 복잡한 트랜잭션 관리를 위해 Saga 패턴이 왜 큰 도움이 되는지 이해가 갔음.
- 데이터베이스 정규화와 ACID 원칙을 정립하는 과정에서, 과도한 정규화가 오히려 비효율적일 수 있다는 점과, 트랜잭션의 핵심 의미를 재확인하는 계기가 되었음.
- 격리 수준과 발생하는 부작용(Dirty Read, Non-Repeatable, Phantom Read)을 구체적 예시와 함께 정리하였음. 이러한 문제를 해결하는 Lock과 MVCC의 역할을 깊게 이해하게 되었음.
- GC와 메모리 관리 전략에서, Reachability와 Stop-The-World 문제의 본질을 다시 생각하면서, 가비지 컬렉터의 왜 존재하는지, 그리고 JVM이 어떻게 효율적 데이터 유지와 정리를 하는지에 대해 정리했음.
- 세대별 가설을 통해 GC의 실무적 효율성을 다시 체감했고, System.gc() 호출의 비효율성과 그 대안을 고민하는 시간도 가졌음.

## 🛠️ Troubleshooting & Insight
- 객체와 데이터베이스 구조를 설계할 때, 왜 그렇게 설계했는지 명확히 설명할 수 있어야 한다는 원칙이 명확해졌음. 단순히 기능을 구현하는 것보다 왜 그 방식이 논리적이고 효율적인지 설명하는 게 중요하다고 느껴짐.
- 실무에서 지속적으로 의문을 품으며 설계의 최적점을 찾으려고 하는 노력이 필수임을 체감했고, 이러한 고민이 앞으로 더 좋은 백엔드 개발자로 성장하는 기반임을 확신했음.

## 🎯 Next Step
- 빌더와 ToBuilder 패턴을 실제 프로젝트에 적용하는 방법과 그 사례들을 더 공부할 것.
- 데이터베이스의 정규화 수준 결정 기준과 성능 최적화 사례들을 정리하여 문서화할 것.
- 분산 트랜잭션 복잡성을 낮추기 위한 다른 패턴이나 기법들도 탐색할 예정.