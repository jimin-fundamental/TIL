# 20260211: Spring @Transactional과 Outbox Pattern 이해하기

## 💡 Key Context
> 오늘은 Spring의 @Transactional 작동 원리와 데이터 정합성을 위한 Outbox Pattern을 접했다. 특히, 트랜잭션 내부에서 메시지 발행과 DB 저장을 동시에 처리하는 방법이 궁금했고, 이를 위해 아웃박스 테이블을 활용하는 방식을 배웠다. 실무에서 분산 트랜잭션의 문제를 해결하는 한 방법으로 느껴졌다.

## 🔍 Deep Dive & Reasoning
- Spring의 @Transactional은 AOP와 Proxy를 통해 동작하며, 트랜잭션 시작 시 프록시 객체가 가로채서 DB 커넥션에 `setAutocommit(false)`를 걸고, 커밋/롤백 시 함께 처리하는 구조라는 걸 이해했다.
- DB 격리 수준과 각 문제점들을 정리하면, MVCC와 Next-Key Lock 덕에 MySQL에서는 논리적 문제가 어느 정도 해결되지만, 여전히 분산 시스템에서의 정합성은 별개 문제임을 느꼈다.
- 특히, 아웃박스 패턴은 메시지 유실 방지와 최종적 일관성을 위해 매우 유용하다는 점에서 공감했다. DB에 일단 메시지를 저장하고, 별도 프로세스(Relay)가 이를 읽어 메시지 큐로 보내는 구조는 직관적이지만, 구현 시 고려할 게 많을 듯하다.
- 메시지 발행 방식을 폴링과 CDC로 나누는 점이 흥미로웠다. 실시간성을 고려할 때 선택 기준이 명확해지고, Debezium 같은 툴도 실제로 많이 쓰는구나 생각했다.

## 🛠️ Troubleshooting & Insight
- 처음에는 메시지 전송과 DB 커밋을 일치시키는 게 어려워 보였는데, 명확한 분리와 별도 프로세스 설계 덕분에 해결 가능하다고 봤다.
- 메시지 중복 문제와 멱등성 처리 문제도 반드시 고려해야 할 포인트임을 깨달았으며, 실무에서는 그런 이슈를 방지하는 로직이 필요하다는 점이 인상적이었다.

## 🎯 Next Step
- Outbox Pattern을 실제 프로젝트에 어떻게 구현하는지 구체적인 사례를 공부하고, Debezium이나 비슷한 CDC 툴의 구조를 좀 더 깊게 파악할 것.