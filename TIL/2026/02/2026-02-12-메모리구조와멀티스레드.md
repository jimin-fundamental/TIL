# 20260212: 메모리 구조와 멀티스레드 동시성 제어에 대한 고민

## 💡 Key Context
> 오늘은 파일 시스템, 메모리 구조, 멀티스레드 처리 세션을 정리하면서 왜 이런 구조들이 존재하는지, 그 내부 원리를 묻게 됐다. 특히 동시성 문제 해결책이 왜 필요한지 실제 사례와 겹쳐서 이해하려고 노력했는데, 완전 명쾌하진 않더라도 의문은 좀 풀린 듯함.

## 🔍 Deep Dive & Reasoning
- 파일 시스템의 하드 링크와 심볼릭 링크 차이, 그리고 I-node가 갖는 의미를 다시 한 번 떠올리면서, 왜 원본의 메타데이터를 공유하는지에 대한 문제의 핵심은 데이터 일관성 유지와 공간 절약에 있는 것 같다. 하드 링크는 여러 이름이 하나의 I-node를 가리키게 해서 변경 내역 공유가 가능하고, 심볼릭 링크는 참조 경로만 달아 놓는 방식이니까 엄연히 다른 역할이구나.
- 시스템 콜을 통해 유저 모드 요청이 커널을 거치는 구조는 보안과 안정성에 크게 기여하는데, 이 과정을 통해 추상화가 잘 되는 것 같다. 다만, 성능 이슈로 CPU와 L1/L2/L3 캐시, TLB가 왜 중요한지에 대한 연관성은 아직 명확히 이해 미진.
- Static 변수와 TLB를 어떻게 연결 짓는지, 그리고 GC와 멀티스레드 환경에서 Static이 어떤 위험을 내포하는지에 대해 생각해봤는데, 결국 공유 자원에 대한 적절한 동기화가 필수인 듯 함.
- 멀티스레드의 Context Switch는 오버헤드와 캐시 미스 발생을 야기하는데, 이를 최소화하는 게 성능 최적화 포인트이고, synchronized와 AtomicInteger도 각각의 Trade-off가 있구나. 특히 CAS를 쓰는 이유는 락보다 가볍고 빠르게 원자성 확보하려는 것임을 다시 확인.
- 데드락 방지 전략으로 자원 할당 순서가 중요하고, 환형 자원 대기 조건을 알면 조금은 방지 전략을 세울 수 있겠다는 생각.
- Redis 구조를 보면서, In-Memory DB가 갖는 강점이 CPU의 한계 내에서 최대한 빠른 데이터 처리를 가능하게 하는구나. 이벤트 루프, I/O 멀티플렉싱 등 비동기 처리 구조도 참고할 만함. 백업 방법은 빠른 복구와 데이터 안전을 위해 구분해서 쓰는 것 같고.

## 🛠️ Troubleshooting & Insight
- 원래는 C나 메모리 모델에 대해 구체적으로 떠올리기 귀찮았는데, 오늘은 각각의 원리와 왜 중요한지에 대해 다시 생각하는 계기가 됐다. 특히 멀티스레드 환경에서의 동기화 문제와 캐시 일관성의 복잡성을 머릿속으로 정리하는 게 핵심이었음.
- 또한, 이해한 내용을 간단히 정리하면서 내가 흐를 법한 사고 과정을 피드백 받거나 더 깊이 파고들 방법을 고민하게 됨.

## 🎯 Next Step
- 각각의 상세 구조와 원리들이 어떻게 서로 연결되어 성능과 안정성을 높이는지 더 깊게 파고들 필요가 있다.