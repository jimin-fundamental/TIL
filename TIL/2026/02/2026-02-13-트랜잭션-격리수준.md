# 20260213: 트랜잭션 격리수준에 대한 이해와 실무 적용 고민

## 💡 Key Context
> 오늘 접한 내용은 트랜잭션 격리 수준이었어요. 특히 여러 트랜잭션이 동시에 실행될 때 데이터를 얼마나 볼 수 있는지 기준을 세우는 중요한 개념이라서 참고했어요. 실무에서는 데이터 정합성과 성능 사이 균형 잡는 게 중요하니까 의미가 깊다고 생각했어요.

## 🔍 Deep Dive & Reasoning
- 격리 수준은 낮을수록 성능은 좋아지지만 데이터 문제 가능성도 높아지고, 높을수록 정합성은 좋아지지만 성능 저하가 클 것 같아요.
- 예를 들어, Read Uncommitted는 가장 빠르지만 Dirty Read 문제가 있어서 피하고 싶고, Serializable은 모든 이상 현상 방지하지만 성능이 크게 떨어질 것 같음.
- MySQL은 기본적으로 Repeatable Read를 사용하는데, 이것도 Phantom Read를 방지하지 못하니까 그 부분은 고민이 필요하겠어요. PostgreSQL은 Read Committed를 기본으로 하고 있던데, 실제 환경에 적용할 때 어떤 선택이 최선일지 체크해야 함.
- 도서관 비유는 처음에 직관적으로 이해하는데 도움이 됐어요. 읽기 격리 수준을 비유로 꾸민 게 인상적였어요.
- 실무에서는 대부분 Read Committed나 Repeatable Read면 충분하다고 하니까, 금융 같은 민감한 용도에서는 Serializable도 고려하는 게 맞겠어요.

## 🛠️ Troubleshooting & Insight
- SET TRANSACTION ISOLATION LEVEL 명령어를 통해 격리 수준을 유동적으로 변경하는 것도 방법이겠더라고요. 설정에 따라 시스템 성능과 데이터 정합성을 조절하는 전략이 필요할 것 같음.
- 배우면서 json requestbody로 받는 것도 언급됐는데, 이건 별개지만 필드명을 자동으로 매핑해주는 것이 개발 효율을 높인다고 느꼈어요.

## 🎯 Next Step
- 각 데이터베이스(DBMS)별로 기본 격리수준이 무엇인지, 실제 환경에서 어떤 규칙을 적용하는지 더 알아볼 것.