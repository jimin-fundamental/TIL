# 20260205: 멀티 프로세스와 스레드, Non-blocking I/O, 그리고 설계 원칙에 대해 정리함

## 💡 Key Context
> 오늘은 OS, Java, 설계 원칙, Linux 트러블슈팅, 그리고 네트워크 아키텍처에 관련된 내용을 정리하는 계기였다. 특히 멀티 프로세스와 멀티 스레드의 차이, C10K 문제 해결책, GC 원리, 그리고 DIP 원칙이 인상적이었다. 이 내용을 통해 현업 프로젝트와 연관지어 심층적 이해를 기대하는 중이었다.

## 🔍 Deep Dive & Reasoning
- 멀티 프로세스는 자원 공유가 어려운 반면, 멀티 스레드는 메모리 공유가 쉬워서 다양한 상황에 맞게 선택하는 게 중요한 것 같음. 예를 들어, 여러 프로세스가 독립적일 때는 프로세스 기반이 유리하고, 자원 공유가 필수면 스레드 쪽이 적합하겠지.
- C10K 문제 해결책으로 Non-blocking I/O(Event Loop)와 Thread Pool이 핵심인데, 그냥 스레드 늘리면 메모리 문제, 컨텍스트 전환 오버헤드가 크니까, 비동기로 처리하는 게 장기적으로 더 효율적임을 다시 한 번 깨달음.
- GC는 Young과 Old 영역이 있는데, 흔히 생각하는 것과 달리 Minor GC(Young)가 훨씬 자주 일어나고, Old 영역은 오래 살아남은 객체들이 모이는데, 이것 때문에 메모리 관리 정책이 복잡해지는 듯함.
- DIP 원칙을 적용하면 인터페이스를 통해 결합도를 낮추고 유연한 설계 가능함. 이는 인프라 변경이나 확장에 유리하다고 생각되는데, 실무에서도 신경 써야 하는 부분임.
- 리눅스 프로세스 관리는 top, ps, kill 명령어들을 조합해서 이루어지고, kill -15를 먼저 사용하며, kill -9는 데이터 유실 위험이 있기 때문에 신중하게 써야 함.
- API Gateway는 한마디로 클라이언트 단순화를 위한 것인데, 동시에 단일 장애점(SPOF)을 의식해야 하니 HA 구성을 고민하는 것이 자연스럽다고 봄.

## 🛠️ Troubleshooting & Insight
- GC 빈도에 대해 헷갈렸던 점: Old 영역보다 Young이 훨씬 자주 가비지 컬렉션이 일어난다는 점을 다시 재확인했고, 특히 Minor GC가 실무에서 대부분 차지함. 이 부분은 JVM 튜닝할 때 참고할 것.
- kill 명령어 사용 시, 무조건 강제 종료하기보다 최대한 부드럽게 종료하는 습관을 기르는 게 유실 방지에 도움됨. 처음엔 무서워서 바로 -9 썼지만, 이후 조심스럽게 -15로 먼저 시도하는 습관을 들이겠다.
- C10K 문제는 단순히 더 많은 스레드보다 비동기 I/O 접근이 핵심임을 다시 체감. 이 논리의 통합적 이해가 필요하다고 느낌.

## 🎯 Next Step
- 메일 서버 아키텍처 설계 방향을 구상하는 것으로 유지하면서, 로드 밸런싱과 HA 고려사항 구체화할 것.
- 네트워크 관련 이론과 실습을 병행하며, 실무에 바로 적용 가능한 수준까지 공부할 것.