# 20260202: 가상 메모리와 프로세스 관리, 동기/비동기 이해와 파일 및 프로세스 차이 정리

## 💡 Key Context
> 오늘은 가상 메모리 동작 원리와 좀비 프로세스, 그리고 OS의 스케줄링 구조에 대해 정리했다. 특히, 가상 주소와 페이지 테이블, Page Fault 처리 과정이 처음 명확히 떠오르지 않아 고민했고, 좀비 프로세스의 구조적 대응책에 대해 다시 생각하는 계기가 됐다. 또한, 동기와 비동기 차이, 그리고 프로세스와 스레드의 차이도 동시에 정리하며, 파일 전체적인 역할과 설계 이유에 대해 다시 떠올려봤다.

## 🔍 Deep Dive & Reasoning
- 가상 메모리는 물리 메모리 크기를 초과하는 프로그램도 동작하게 하는 기술로, 페이지 테이블이 핵심 역할을 담당한다. 페이지 교체 전략인 LRU를 통해 제한된 RAM 용량 내에서 효율적 동작이 가능함을 이해했다.
- 좀비 프로세스는 종료했지만 부모가 자식의 종료 상태를 수집하지 않아 시스템 자원 누수 문제가 발생하는데, 이를 방지하기 위해 부모가 자식의 상태를 회수하는 구조가 필수임을 새롭게 깨달았다.
- 동기와 비동기의 차이는 작업의 진행과 기다림 전략에 있다. 스케줄링 정책은 FCFS와 SJF로 나뉘며, 각기 장단점이 있다는 점을 정리하는 데 오랜 시간이 걸렸다. 특히, SJF는 최적이지만, 실행 시간 예측이 어려운 문제도 갖고 있음을 직감했다.
- IPC와 스레드 공유 메모리의 차이를 이해하는 과정에서, 공유 범위와 소유권 개념이 확실하지 않았던 걸 정리하면서, 범위 차이를 명확히 했다.
- 메모리 단편화와 페이지, 세그먼트 차이, 세마포어와 뮤텍스 차이도 다시 깊이 이해하는 계기가 됐다. 특히, 상호 배제 원칙이 동시 접근 차단이 아니라 접속 제한임을 확실히 했다.

## 🛠️ Troubleshooting & Insight
- 파일은 OS의 자원 관리 차원에서 모든 것이 파일이라는 철학이 놀라웠다. 실제 설계에서, 디바이스, 소켓, 파이프 등 자원들이 통일된 인터페이스로 관리되는 구조는 이해했으나, 코딩 관점에서는 어떻게 구현될지 감이 잘 오지 않았다.
- 오늘 정리하면서, 커맨드를 하나씩 단계별로 commit 하는 습관이 좋다는 점을 다시 느꼈다. 여러 내용들을 하나의 커밋에 담으려 했는데, 작업 분할이 명확해야 나중에 체크하기 쉽겠다는 생각이 들었다.

## 🎯 Next Step
- 가상 메모리 상세 동작 과정, 특히 페이지 폴트와 교체 알고리즘 구현 원리를 구체적으로 다시 학습할 것.
- 좀비 프로세스의 시스템 콜 처리 구조를 그림으로 그려보고, 부모-자식 프로세스 간 자원 회수 정책 차이를 정리할 것.
- 동기와 비동기, 스케줄링 알고리즘에 대한 성능 비교 사례를 찾아보고, 실무 적용 가능성을 검토할 것.
- IPC와 스레드의 차이와 활용 사례를 실제 시스템 예제를 통해 정리할 것. 특히, 공유 메모리와 메시지 큐의 차이와 적합한 사용 시나리오를 학습할 것.