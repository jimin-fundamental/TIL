# 20260131: 가상 메모리와 프로세스 관리, 동기/비동기, 그리고 OS 스케줄링에 대해 고민하며 배운 점 정리

## 💡 Key Context  
> 오늘은 가상 메모리, 프로세스와 스레드, 그리고 OS의 스케줄링 원리를 접하면서 기존에 막연하게만 알고 있던 개념들을 좀 더 구체화시켜보는 계기였다. 특히 꼬리부분의 상세한 설명과 예시를 통해 내부 로직 흐름에 대해 자연스럽게 체화하려고 노력함.

## 🔍 Deep Dive & Reasoning  
- 가상 메모리가 4GB보다 큰 프로그램을 가능하게 하는 이유는, 현재 필요한 부분만 메모리에 올리고 나머지는 디스크에 보관하는 가상 메모리 기법 때문임. CPU가 가상 주소를 보고, 페이지 테이블을 통해 물리 주소로 변환하는 구조도 익숙했는데, 페이지 테이블은 RAM에 위치하고 필요시 디스크에서 페이지를 로드한다는 점이 핵심.
- 좀비 프로세스는 프로세스가 종료됐음에도 부모가 종료 신호를 받지 않아서 시스템 프로세스 테이블에 남는 현상. 이를 방치하면 PID 고갈 등 문제가 발생하니까, 강제 종료보다 부모가 회수하는 구조가 중요하다고 인지.
- 동기와 비동기의 차이는, 동기는 결과를 기다리고(블로킹), 비동기는 기다리지 않거나 계속 체크하는 것(논블로킹)이 핵심이고, OS는 CPU 스케줄러를 통해 어떤 프로세스에 CPU를 배분할지 결정하는 역할을 함. SJF는 평균 대기 시간을 줄이기 위해 최단 작업 우선순위를 따르지만, 기아와 같은 한계도 명확히 알게 됨.

## 🛠️ Troubleshooting & Insight  
- 프로세스와 스레드의 차이, 그리고 메모리 관리상의 구분이 헷갈릴 때, 각각의 생명주기와 데이터 공유 범위를 명확히 해야 하는구나 깨달음. 실무에서는 이 구분이 중요한 것도 이해했고.
- 특히 세마포어와 뮤텍스 차이에서 개별 프로세스와 스레드의 소유권 개념, 데드락 예방 전략이 실무에 도움 될 구조임을 느꼈음. 내부 단편화와 외부 단편화를 구분하는 것도 기억해두기.

## 🎯 Next Step  
- 가상 메모리에서 페이지 교체 알고리즘(LRU 등)이 어떤 조건과 상황에서 우선순위가 달라지는지 좀 더 구체적으로 학습할 것.
- 프로세스와 스레드 설계 시, 메모리 관리와 병행하는 동기/비동기 고성능 구현 사례를 찾아봐야겠음.